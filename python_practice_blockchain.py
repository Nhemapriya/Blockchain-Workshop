# -*- coding: utf-8 -*-
"""Python_practice_Blockchain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16NnMIK95Kc6-00AOLMfXJH94A-THkttI
"""

def combine():
  l =[]
  my_str = ""
  n = int(input("enter n"))
  for i in range(n):
    l.append(input())
  str1 = input("string 1")
  str2 = input("string 2")
  i1 = l.index(str1)
  i2 = l.index(str2)

  try:   
    if i1==n-1 and i2==0:
      raise Exception("whoo .. invalid index is given")

    for i in range(i1+1, i2):
      my_str += l[i]
    print(my_str)

  except Exception as error:
    print(error)

combine()

"""# DAY 2"""

#print the square of number
#TASK 1
def practiceProgram():
  num = int(input("enter value"))
  print(num**2)

#square of a number always use num**2

practiceProgram()

#Dictionary operations
def dictionaryOperations():
  bus = {}
  bus_id = int(input("enter the bus number"))
  bus_src = input("bus start")
  bus_dest = input("bus destination")
  fuel = int(input("enter the fuel capacity"))
  seats = int(input("enter number of seats"))
  bus["bus_number"]= bus_id
  bus["bus_source"]= bus_src
  bus["bus_destination"] = bus_dest
  bus["fuel_capacity"]= fuel
  bus["total_seats"]= seats
  print(bus)

#Functional call
dictionaryOperations()

class Bus:
  source = "OMR"
  destination = "TMBRM"
  seats = 25
  busNumber = "D70"
  fuel = "diesel"
  speed =0
  capacity=0

  def __init__(self, speed, capacity):
    print("constructor of bus")
    self.speed = speed
    self.capacity = capacity

college = Bus(45, 3)
# #new bus fpr SJCE
# sjceBusNumber = Bus()
# #new bus for SJIT
# sjitBusNumber = Bus()
# #new bus for SAIRAM
# sairamBusNumber = Bus()
#new bus for SSN
# ssnBusNumber = Bus()


print("No of seats",college.seats)
# print("speed of bus", college.speed)
print("bus number", college.busNumber)
print("speed ", college.speed)
print("capacity ", college.capacity)



"""# TASK 10"""

n = 10
for i in range(n):
  if i==5:
    break
  else:
    print(i)

# import keyboard
# i=0

# while True:
#   if keyboard.is_pressed("q"):
#     break


# # except Exception as err:
# #   print(err)

"""# speech recognition"""

!pip install pyaudio

pip install SpeechRecognition

import speech_recognition as sr
sr.__version__

# r = sr.Recognizer()
# with sr.Microphone() as source:
#     print("say")
#     audio = r.listen(source)

from io import BytesIO
from base64 import b64decode
from google.colab import output
from IPython.display import Javascript

RECORD = """
const sleep  = time => new Promise(resolve => setTimeout(resolve, time))
const b2text = blob => new Promise(resolve => {
  const reader = new FileReader()
  reader.onloadend = e => resolve(e.srcElement.result)
  reader.readAsDataURL(blob)
})
var record = time => new Promise(async resolve => {
  stream = await navigator.mediaDevices.getUserMedia({ audio: true })
  recorder = new MediaRecorder(stream)
  chunks = []
  recorder.ondataavailable = e => chunks.push(e.data)
  recorder.start()
  await sleep(time)
  recorder.onstop = async ()=>{
    blob = new Blob(chunks)
    text = await b2text(blob)
    resolve(text)
  }
  recorder.stop()
})
"""

def record(sec=3):
  print("Speak Now...")
  display(Javascript(RECORD))
  sec += 1
  s = output.eval_js('record(%d)' % (sec*1000))
  print("Done Recording !")
  b = b64decode(s.split(',')[1])
  return b #byte stream

record()

"""# tasks"""

def deloperation():
  n=int(input())
  l=[]
  print("names")
  for i in range(n):
    l.append(input())
  
  str1 = input()
  l.append(str1)
  l.pop()
  l.insert(3, str1)
  print(l)

deloperation()

"""# Blockchain implementation"""

import hashlib


#create a basic block
class neuralCoinBlock:
  
  def __init__(self, prevBlockHash, transList):
    self.prevBlockHash = prevBlockHash
    self.transList = transList
    #obtain the data of the block
    self.blockData = "-".join(transList)+"-"+prevBlockHash
    self.blockHash = hashlib.sha256(self.blockData.encode()).hexdigest

t1 = "this is the first transaction"
t2 = "this is the second transaction"
t3 = "this is the third transaction"

initialBlock = neuralCoinBlock("password to be encrypted", [t1, t2])

initialBlock.blockData
initialBlock.blockHash

secondBlock = neuralCoinBlock(initialBlock.blockHash, [t1,t2])
secondBlock.blockHash

"""# Decentralized food delivery rating system"""

import hashlib
from time import gmtime, strftime
class neuralMainBlock:

  def __init__(self, uniqueId, prevBlockHash, lastUpdated):
    self.uniqueId = uniqueId
    self.firstTrans = strftime("%Y-%m-%d %H:%M:%S", gmtime())
    self.prevBlockHash = prevBlockHash
    self.lastUpdated = lastUpdated
    # self.blockData = "-".join(transList)+"-"+prevBlockHash
    self.blockHash = hashlib.sha256(self.uniqueId.encode()).hexdigest()

class UserBlock:

  def __init__(self, userId, rating, prevBlockHash,userData):
    self.userId = userId
    self.rating = rating
    self.prevBlockHash = prevBlockHash
    self.userData = userData+prevBlockHash
    self.blockHash = hashlib.sha256(self.userData.encode()).hexdigest()
    self.time = strftime("%Y-%m-%d %H:%M:%S", gmtime())

userId = input("enter unique id")
deliveryStatus = input("enter delivery status - success or failure")
deliveryData = input("enter the time, location of delivery")
# myHash = 
if deliveryStatus =="success":
  user = UserBlock(userId, 5, hashlib.sha256(userId.encode()).hexdigest(), deliveryData)
else:
  user = UserBlock(userId, 3, hashlib.sha256(userId.encode()).hexdigest(), deliveryData)

# print(user.userData)
print(user.blockHash)
# print(user.rating)
main = neuralMainBlock(user.userId, user.blockHash, user.time)
print(main.lastUpdated)
print(main.prevBlockHash)

"""# DAY 3 - 28-10-2021"""

#BLOCKCHAIN IMPLEMENTATION FOR CRIMINAL CASE RECORD MANAGEMENT
import hashlib
#create a basic block
class neuralCoinBlockCreation:
  
  def __init__(self, prevBlockHash, transList):
    self.prevBlockHash = prevBlockHash
    #obtain the data of the block
    self.blockData = transList
    self.blockHash = hashlib.sha256(self.blockData.encode()).hexdigest

t1 = "Criminal 1 ABC - murder suspect"
t2 = "Criminal 2 XYZ - Theft suspect"
t3 = "Criminal 3 PQR - Chain snatchers"
t4 = "Criminal 4 EFG - Theft"

initialBlock = neuralCoinBlockCreation("password to be encrypted", t1)
secondBlock = neuralCoinBlockCreation(initialBlock.blockHash, t2)
thirdBlock = neuralCoinBlockCreation(secondBlock.blockHash, t3)
fourthBlock = neuralCoinBlockCreation(thirdBlock, t4)

"""**CASE FILE - DATASET CREATION**"""

caseFileDirectory = []

caseGenesisBlock = {
    "caseId": 1,
    "caseName" : "Murder",
    "caseStartDate" : "28-09-2021",
    "caseStatus": "In-progress",
    "caseFiledBy" : "Hema",
    "caseFiles" : "FIR, medical proof, blood samples, eye-witness proof",
    "caseRunBy" : "Lawyer ABC",
    "caseFiledLocation": "chennai",
    "caseFiledAgainst": "priya",
    "caseSuspects": "ABC, XYZ",
    "caseVictimSuspect": "PQR",
    "caseWitness" : "LMN"
}

#Add the genesis block to directory
caseFileDirectory.append(caseGenesisBlock)


#details about case and related information
def getCaseInformation(id):
  print("enter the required case details")
  caseDetails = {}
  caseDetails["caseId"] = id
  caseDetails["caseName"] = input("enter the case name")
  caseDetails["caseStartDate"] = input("enter the start date of case")
  caseDetails["caseStatus"] = input("progress of the case")
  caseDetails["caseType"] = input("enter the type of the case")
  caseDetails["caseFiledBy"] = input("who filed the case")
  caseDetails["caseFiles"] = input("details of case files")
  caseDetails["caseRunBy"] = input("who runs the case")
  caseDetails["caseFiledLocation"] = input("location of the case")
  caseDetails["caseFiledAgainst"] = input("filed against ? ")
  caseDetails["caseSuspects"] = input("suspected people")
  caseDetails["caseVictimSuspect"] = input("suspected individuals for victim")
  caseDetails["caseWitness"] = input("witness details")
  sectionDetails={}
  sectionDetails["sectionId"] = input("enter the section id")
  sectionDetails["sectionRule"] = input("enter the rule for the section")
  sectionDetails["sectionNumber"] = input("enter the number for the section")
  sectionDetails["sectionReference"] = input("enter reference number") 
  caseDetails["sectionDetails"]=sectionDetails
  caseFileDirectory.append(caseDetails)

caseFileDirectory

#create case details
numberOfCaseInputs = int(input("enter the number of case details to be given"))
for num in range(numberOfCaseInputs):
  getCaseInformation(num+1)

caseFileDirectory

"""**ADD DETAILS TO THE BLOCKCHAIN**"""

import hashlib
from time import gmtime, strftime
class MainBlockChain:

  def __init__(self, uniqueId, prevBlockHash, caseType):
    self.uniqueId = uniqueId
    self.firstTrans = strftime("%Y-%m-%d %H:%M:%S", gmtime())
    self.prevBlockHash = prevBlockHash
    self.caseType = caseType
    # self.blockData = "-".join(transList)+"-"+prevBlockHash
    self.blockHash = hashlib.sha256(self.prevBlockHash.encode()).hexdigest()

class MurderBlock:

  def __init__(self, caseId, prevBlockHash,userData):
    self.caseId = caseId
    self.prevBlockHash = prevBlockHash
    self.userData = userData
    self.blockHash = hashlib.sha256(self.prevBlockHash.encode()).hexdigest()
    self.time = strftime("%Y-%m-%d %H:%M:%S", gmtime())

class TheftBlock:
  def __init__(self, caseId, prevBlockHash,userData):
    self.caseId = caseId
    self.prevBlockHash = prevBlockHash
    self.userData = userData
    self.blockHash = hashlib.sha256(self.prevBlockHash.encode()).hexdigest()
    self.time = strftime("%Y-%m-%d %H:%M:%S", gmtime())

caseFileDirectory

#add genesis block initailly and obtain the hash of it
genesisId = "first block"
genesisBlock = MainBlockChain(1, hashlib.sha256(genesisId.encode()).hexdigest(), "neutral")
# genesisBlock.blockHash
# genesisBlock.caseType

latestPreviousBlockhash = genesisBlock.blockHash
latestPreviousBlockhash

import pickle
#check with the index and type of case and create block
#murder block index and theft block index is created
murderIndex = []
theftIndex = []
mainIndex = []
for case in caseFileDirectory:
  if case['caseName']=="Murder":
    caseString = pickle.dumps(case)
    newMurderBlock = MurderBlock(case["caseId"],latestPreviousBlockhash,caseString)
    latestPreviousBlockhash = newMurderBlock.blockHash
    murderIndex.append([newMurderBlock.blockHash, newMurderBlock.time])
    mainBlock = MainBlockChain(case["caseId"],newMurderBlock.blockHash, case["caseName"])
    mainIndex

  elif case['caseName']=="Theft":
    caseString = pickle.dumps(case)
    newTheftBlock = TheftBlock(case["caseId"],latestPreviousBlockhash,caseString)
    latestPreviousBlockhash = newTheftBlock.blockHash
    theftIndex.append([newTheftBlock.blockHash, newTheftBlock.time])
    mainBlock = MainBlockChain(case["caseId"], newTheftBlock.blockHash, case["caseName"])

murderIndex
# theftIndex

"""**connect with main blockchain**"""





